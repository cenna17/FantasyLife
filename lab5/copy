.section .note.GNU-stack,""
.extern lab5
.text

.global fibonacci
.global polynomial1
.global polynomial2

.global is_odd1
.global is_odd2

.global mul1
.global mul2

#x=rdi a=rsi b=rdx c=rcx d=r8
polynomial1:
push %rbx
mov $0, %rbx

############## CALCULATE ax^3
mov $1, %rax #curr = 1
mul %rdi #curr = x
mul %rdi #curr = x^2
mul %rdi #curr = x^3
mul %rsi #curr = ax^3
add %rax, %rbx #sum = ax^3

############### CALCULATE bx^2
mov $1, %rax #curr = 1
mul %rdi #curr = x
mul %rdi #curr = x^2
mul %rdx #curr = bx^2
add %rax, %rbx #sum = ax^3 + bx^2

############## CALCULATE cx + d
mov $1, %rax #curr = 1
mul %rdi #curr = x
mul %rcx #curr = cx
add %r8, %rax  #curr = cx + d
add %rax, %rbx #sum = ax^3 + bx^2 + cx + d
mov %rbx, %rax
pop %rbx
ret
polynomial2:
############### CALCULATE x(x(ax+b) + c) + d
mov $1, %rax #curr = 1
mul %rdi #curr = x
mul %rsi #curr = ax
add %rdx, %rax #curr = ax+b
mul %rdi #curr = x(ax+b)
add %rcx, %rax #curr = x(ax+b) + c
mul %rdi #curr = x(x(ax+b) + c)
add %r8, %rax  #curr = x(x(ax+b) + c) + d
ret

RETURN_EVEN: 
mov $0, %rax
ret

RETURN_ODD:
mov $1, %rax
ret

is_odd1:
mov $2, %r8
mov $0, %rdx #remainder
mov %rdi, %rax
idiv %r8

cmp $0, %rdx
je RETURN_EVEN
jmp RETURN_ODD

is_odd2:
and $1, %rdi
cmp $0, %rdi
je RETURN_EVEN
jmp RETURN_ODD

mul1:
mov %rdi, %rax
mov $65537, %rsi
mul %rsi
ret

mul2:
shl $16, %rdi
add $1, %rdi
mov %rdi, %rax
ret


fibonacci: #rdi = n
push %rbx
mov %rdi, %rbx # save n
mov $0, %rax # sum = 0

#init x+y=next_fib_num {0,1}
mov $0, %rdi #init x = 0
mov $1, %rsi #init y = 0
mov $1, %rdx #counter = 1

push %rdi
push %rsi
jmp fib_RECURSIVE

fib_RECURSIVE:
pop %rsi #load y
pop %rdi #load x

cmp $0, %rbx 
je RETURN_ZERO
cmp $1, %rbx
je RETURN_ONE
cmp %rdx, %rbx
je RETURN_SUM

#SUM = x + y
add %rsi, %rax
add %rdi, %rax

add $1, %rdx #counter++
mov %rsi, %rdi
mov %rax, %rsi
push %rdi
push %rsi

RETURN_ZERO:
pop %rbx
ret 
RETURN_ONE:
pop %rbx
mov $1, %rax
ret 

RETURN_SUM:
pop %rbx
ret 




